Description:

Your objective for this assignment is to create an application that receives circle properties (radius, speed & color) from a user. These properties are then used to create a circle that is displayed in a list item where it continually animates from one side of the list item to the another. There is a video attached to this assignment to demonstrate what the final implementation should look like.

Application Layout Requirements

- When a user starts the app, they should be presented with an example of how the custom view works at the top of the screen. This "example" should just be your custom view, CircleAnimatoinView, with a height of 80dp and a width of match_parent. The circle size, circle color, and circle speed of your example view should all be set in XML using custom attributes. Below the example custom view should be text that says "Create Your Own". At the bottom of the screen should be an area for users to create properties for a new circle. This area will be referred to as the "Circle Creation Interface" or CCI for the remainder of this document. A ListView or RecyclerView should fill up all of the remaining space between the "Create Your Own" text and the Circle Creation Interface at the bottom of the screen.

- The Circle Creation Interface should be 80dp tall. It should have an area to enter in the circle's radius on the left side of the screen and an area to enter in the circle's speed (in dp) on the right side of the screen. Below the radius input and on the left side of the screen should be a color picker that the user will use to pick a color for the circle. Tapping on a color in the color picker should de-select a previously selected color and select the color that was clicked on. Tapping on a color that is already selected, should de-select it. To the right of the color picker should be an "Add" button that the user will use to add a circle, with the provided properties, to the list.

- When the user clicks on the "Add" button, you must verify that the user has selected a color and entered in valid radius and speed values. This means that both the radius and the speed have to be non-empty, a valid number, and greater than 0. If any of these cases is not true, show a toast message notifying the user of their error. If there is no error, then a new row should be created in your listview with an animating circle containing the properties specified by the user. All input fields and previously selected colors should be reset.

- When a user clicks on a list item, the CCI should disappear and the user should be presented with controls to adjust the circle's current speed. This area will be referred to as the "Speed Control Interface" or SCI for the remainder of this document. The Speed Control Interface should be the same height as the CCI. In the middle of the SCI should be the circle's current speed in dp. To the left of the current speed text should be a minus button that is used to decrease the circle's speed. The speed should not be allowed to be less than 1. To the right of the current speed text should be a plus button that is used to increase the circle's speed. The speed of the circle should adjust in real-time. In other words, the selected list item's circle should move slower every time the minus button is clicked and move faster every time the plus button is clicked. Clicking on different list items while the SCI is already visible, should update the speed text to the speed of the circle in the list item that was just selected. Clicking on a list item that is already selected should de-select the list item, bring back the CCI and make the SCI disappear.

Custom View Requirements

- Create a custom view called CircleAnimationView. It should simply extend the View class.

- This view should accept three custom attributes: a dimension (dp) attribute called "circleRadius", a color attribute called "circleColor", and a dimension (dp) attribute called "circleSpeed". As the names imply, circleRadius will be used to specify the circle's radius (in dp), circleColor will be used to specify the circle's color, and circleSpeed will be used to specify how many device independent pixels (dp) the circle should move every time the view refreshes itself. If the user does not specify any of these values in XML, defaults should be provided in the CircleAnimatonView class.

- Every CircleAnimationView should have a Circle object associated with it. The Circle object should contain the properties that the user entered for the circle whether in XML or through manual input. This Circle object is what determines what sort of circle is drawn on screen. For instance, if the Circle object associated with a particular CircleAnimationView class has a radius of 25 and a color of red, then a red circle with a radius of 25 should be drawn in the CircleAnimationView's onDraw() method

- When the CircleAnimationView is first drawn on the screen, it should be centered vertically within the CircleAnimationView and the left side of the circle should be touching the left side of the CircleAnimationView. After that, every time the CircleAnimationView's onDraw method is called, the circle should start moving towards the right side of the screen at the speed provided to the CircleAnimationView's Circle object. For instance, if the circle's center value is 0 when the CircleAnimationView is first drawn, and the circle has a speed of 5 pixels, then the first time onDraw is called, the circle's center will be 5px, the second time it is called, the circle's center will be 10px, etc. Once the right side of the circle is touching the right side of the CircleAnimationView, the circle should reverse direction and start moving towards the left side of the screen. Once the left side of the circle is touching the left side of the CircleAnimationView, the circle should reverse direction and start moving towards the right side of the screen. This back and forth should continue forever.  

- The circle's position and radius, MUST be in pixels when the circle is drawn inside CircleAnimationView's onDraw method. For instance, let's say that the circle is given a radius of 5dp and a speed of 10dp when it is first instantiated. And let's say that 1dp = 3px. This means that when the circle is drawn on the screen, its radius should be 15 pixels and it should move 30 pixels every time onDraw is called. 

- To maintain a decent frame rate, onDraw should be called ~60 times a second or once every 16 milliseconds. As previously stated, the circle's position should get updated by its speed value every time onDraw is called. This means that if your circle's speed is 5dp (15px), then in 1 second, your circle should moved approximately 300dp (900px) from where it was a second before.

- When a list item scrolls off the screen, the circle should stop animating. This means that if a list item scrolls off the screen and the circle's center has an x position of 250px, when that same list item is scrolled back onto the screen, the x position of the circle's center should be 250 when the circle starts to animate itself again.
 
Helpful Hints

- Place the method below in a Util class and use it to convert values from dp to pixels. Like I mentioned in class, when dealing with views in Java, everything is done in pixels. 
           public static int dpToPx(int dpValue) {    
               return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dpValue, Resources.getSystem().getDisplayMetrics());
           }

- A key part of this assignment involves having the circle animate. A simple way to achieve this animation would be to update the circle's position and then redraw your custom view with the updated position. You would then want this to repeat for however long your CircleAnimationView is on the screen. The best way to achieve repeating behavior can be found in this gist here: https://gist.github.com/kachi1227/f24659397ac42f8331401f3962a1b34c. My advice would be to run this code first and step through it to make sure that you know how it's working. The code required to make your CircleAnimationView animate isn't too different from what's in this gist. You would basically need to create a Runnable whose sole purpose is to update your custom view. And then you'd need to make this Runnable run once every __ milliseconds so that your CircleAnimationView refreshes at 60 frames per second (60fps)

- The assignment also requires you to stop animating the CircleAnimationView's circle if the list item that contains the CircleAnimationView scrolls off the screen. To achieve this, you need to know two things:
1. How to stop a runnable that's already scheduled to run in the future (this is already mentioned in the gist). If you understand the gist above, then this should not be difficult. It should be clear that if you're using a Runnable to repeatedly redraw your View, then removing that Runnable from the queue should stop the animation.

2. How to know when a view gets removed from the screen. Thankfully, Android has a couple of interfaces that you can use to get notified when a list item has scrolled off a screen and is about to be recycled. If you're using a ListView to complete this assignment, you should attach a RecyclerListener to the ListView using setRecyclerListener (https://developer.android.com/reference/android/widget/AbsListView.html#setRecyclerListener(android.widget.AbsListView.RecyclerListener) ). The RecyclerListener's onMovedToScrapHeap method gets called every time a list row has been scrolled off the screen and is about to be recycled. You can find out more about the RecyclerListener here. If you're using a RecyclerView to complete this assignment, you should attach a RecyclerListener to the RecyclerView using setRecyclerListener (https://developer.android.com/reference/android/support/v7/widget/RecyclerView.html#setRecyclerListener(android.support.v7.widget.RecyclerView.RecyclerListener) ). The RecyclerListener's onViewRecycled method gets called every time an item in the RecyclerView has been scrolled off the screen and is about to be recycled. You can find out more about the RecyclerListener here

- This assignment is a combination of everything we've previously done in the course. More specifically, Homework 1, Homework 2, Homework 3. Understanding how each one of those projects work is required to complete this assignment.


